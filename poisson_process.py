# -*- coding: utf-8 -*-
# ==============================================================
# ポアソン過程に基づくスパイク列の生成
# --------------------------------------------------------------
# このコードは、生物学的なニューロンの発火を模倣するために
# ポアソン過程（Poisson process）を用いてランダムなスパイク列を生成する。
# 各ニューロンは独立した確率過程に従ってスパイクを発火し、
# その結果をスパイクラスタープロットとして可視化する。
# ==============================================================

import numpy as np
import matplotlib.pyplot as plt

# ==============================================================
# 乱数の固定
# --------------------------------------------------------------
# np.random.seed() を用いて乱数を固定し、
# 実行ごとに同じスパイク列が再現されるようにする。
# ==============================================================
np.random.seed(seed=0)

# ==============================================================
# シミュレーション設定
# --------------------------------------------------------------
# dt: 時間刻み幅 [s]
# T : シミュレーション全体の時間 [s]
# nt: 総ステップ数
# n_neurons: ニューロンの数
# ==============================================================
dt = 1e-3
T = 1
nt = round(T / dt)  # シミュレーション時間 (1秒, 1ms刻み)
n_neurons = 10  # ニューロン数（10個）

# ==============================================================
# ポアソンスパイクの設定
# --------------------------------------------------------------
# fr : 平均発火率 [Hz]
# ポアソン過程では、発火間隔（ISI: inter-spike interval）が
# 指数分布に従うという性質を利用する。
# ==============================================================
fr = 30  # 発火率 [Hz]

# ==============================================================
# 発火間隔 (ISI: inter-spike interval) の生成
# --------------------------------------------------------------
# 各ニューロンに対して、平均 1/(fr*dt) ステップ間隔で発火するように
# 指数分布からサンプリングを行う。
# ==============================================================
isi = np.random.exponential(1 / (fr * dt), size=(round(nt * 1.5 / fr), n_neurons))

# ==============================================================
# ISIの累積和を取ることでスパイク時刻を算出
# --------------------------------------------------------------
# 各ニューロンの発火時刻を整数ステップとして表す。
# シミュレーション範囲 (0〜nt-1) を超える場合は除外する。
# ==============================================================
spike_time = np.cumsum(isi, axis=0)  # ISIを累積して時刻に変換
spike_time[spike_time > nt - 1] = 0  # 範囲外の時刻を0に戻す
spike_time = spike_time.astype(np.int32)  # float → int に変換

# ==============================================================
# スパイク列の生成
# --------------------------------------------------------------
# spikes[t, i] = 1 の場合、その時刻tにニューロンiが発火したことを意味する。
# ==============================================================
spikes = np.zeros((nt, n_neurons))  # スパイクを記録する配列
for i in range(n_neurons):
    spikes[spike_time[:, i], i] = 1
spikes[0] = 0  # spike_time=0 の発火を削除（初期状態の不要スパイク）

# ==============================================================
# 統計情報の出力
# --------------------------------------------------------------
# 総スパイク数と平均発火率（1秒あたりのスパイク数）を表示。
# ==============================================================
print("Num. of spikes:", np.sum(spikes))
print("Firing rate:", np.sum(spikes) / (n_neurons * T))

# ==============================================================
# 可視化：スパイクラスタープロット
# --------------------------------------------------------------
# 各ニューロンのスパイク時刻をドットで表示。
# 横軸：時間（s）、縦軸：ニューロンインデックス
# --------------------------------------------------------------
# スパイク列が時間軸上にランダムに分布しており、
# ポアソン過程の「記憶がない」発火特性が確認できる。
# ==============================================================
t = np.arange(nt) * dt
plt.figure(figsize=(5, 4))
for i in range(n_neurons):
    # 各ニューロンのスパイクを点で描画
    plt.plot(t, spikes[:, i] * (i + 1), "ko", markersize=2, rasterized=True)

plt.xlabel("Time (s)")
plt.ylabel("Neuron index")
plt.xlim(0, T)
plt.ylim(0.5, n_neurons + 0.5)
plt.tight_layout()

# 出力をPDFとして保存
plt.savefig("poisson_process.pdf", dpi=300)
plt.show()
