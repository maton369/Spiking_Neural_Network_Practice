# -*- coding: utf-8 -*-
# ==============================================================
# シナプス電流モデルのシミュレーション
# --------------------------------------------------------------
# このスクリプトでは、神経細胞間のシナプス応答を
# 「単一指数関数型」と「二重指数関数型」の2種類で比較する。
#
# 単一指数関数型（Single exponential）は単純な減衰応答を表し、
# 二重指数関数型（Double exponential）は上昇相（rise）と減衰相（decay）を持つ
# より生理学的にリアルなシナプス電流を再現する。
# ==============================================================

import numpy as np
import matplotlib.pyplot as plt

# ==============================================================
# シミュレーション設定
# --------------------------------------------------------------
# dt : 時間刻み幅 [s]
# td : シナプス電流の減衰時定数 [s]（decay time constant）
# tr : シナプス電流の立ち上がり時定数 [s]（rise time constant）
# T  : シミュレーション全体の時間 [s]
# nt : 総ステップ数
# ==============================================================
dt = 5e-5  # 時間ステップ（50 µs）
td = 2e-2  # 減衰時定数（20 ms）
tr = 2e-3  # 立ち上がり時定数（2 ms）
T = 0.1  # シミュレーション時間（100 ms）
nt = round(T / dt)  # ステップ数

# ==============================================================
# 単一指数関数型シナプス電流のシミュレーション
# --------------------------------------------------------------
# モデル式：
#   dr/dt = -r/td + spike/td
#
# 「spike=1」は時刻t=0での入力スパイクを意味し、
# 以降は指数関数的に減衰する電流が生成される。
# ==============================================================
r = 0  # 初期状態（シナプス電流の初期値）
single_r = []  # 記録用配列

for t in range(nt):
    spike = 1 if t == 0 else 0  # 最初のタイムステップでのみスパイクを入力
    single_r.append(r)  # 現在のr値を保存
    # オイラー法による時間発展
    r = r * (1 - dt / td) + spike / td
    # （指数近似式でも同様の結果: r = r*np.exp(-dt/td) + spike/td）

# ==============================================================
# 二重指数関数型シナプス電流のシミュレーション
# --------------------------------------------------------------
# モデル式：
#   dr/dt = -r/tr + h_r
#   dh_r/dt = -h_r/td + spike / (tr*td)
#
# → 上昇相(tr) と 減衰相(td) を別々にモデリングし、
#    生理的シナプス応答の「急上昇→緩やかな減衰」を再現。
# ==============================================================
r = 0  # シナプス電流
hr = 0  # 補助変数（上昇相の影響を表す項）
double_r = []

for t in range(nt):
    spike = 1 if t == 0 else 0  # t=0 でのみスパイク入力
    double_r.append(r)  # 記録
    # オイラー法による更新
    r = r * (1 - dt / tr) + hr * dt
    hr = hr * (1 - dt / td) + spike / (tr * td)
    # （指数近似でも記述可能: r = r*np.exp(-dt/tr) + hr*dt など）

# ==============================================================
# 可視化
# --------------------------------------------------------------
# 上: 単一指数型（破線）
# 下: 二重指数型（実線）
# 二重指数関数の方が、立ち上がりが緩やかでより生理的。
# ==============================================================
time = np.arange(nt) * dt
plt.figure(figsize=(4, 3))
plt.plot(
    time, np.array(single_r), linestyle="dashed", color="k", label="single exponential"
)
plt.plot(time, np.array(double_r), color="k", label="double exponential")
plt.xlabel("Time (s)")
plt.ylabel("Post-synaptic current (pA)")
plt.legend()
plt.tight_layout()

# 結果の保存
plt.savefig("exp_synapse.pdf")
plt.show()
