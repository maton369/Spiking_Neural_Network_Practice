# -*- coding: utf-8 -*-
# ==============================================================
# 不応期付きポアソン過程 (Poisson Process with Dead time, PPD)
# --------------------------------------------------------------
# このスクリプトは、単純なポアソン過程に「不応期 (refractory period)」を導入したモデル。
# 各ニューロンは確率 fr*dt でスパイクを発火するが、
# 発火後 t_ref 秒間は新たなスパイクが発生しないよう制限されている。
# 生物学的なニューロンの発火特性に近いモデル化を実現。
# ==============================================================

import numpy as np
import matplotlib.pyplot as plt

# ==============================================================
# 乱数シードの固定（再現性確保）
# ==============================================================
np.random.seed(seed=0)

# ==============================================================
# シミュレーション設定
# --------------------------------------------------------------
# dt: 時間刻み幅 [s]
# T : シミュレーション時間 [s]
# nt: ステップ数 (T/dt)
# n_neurons: シミュレーションするニューロン数
# ==============================================================
dt = 1e-3
T = 1
nt = round(T / dt)
n_neurons = 10

# ==============================================================
# モデルパラメータ
# --------------------------------------------------------------
# tref : 不応期 [s] — 発火後、一定時間スパイクが抑制される期間
# fr   : 平均発火率 [Hz]
# ==============================================================
tref = 5e-3  # 不応期 [s]
fr = 30  # 発火率 [Hz]

# ==============================================================
# スパイク記録用の配列
# --------------------------------------------------------------
# spikes[t, i] = 1 の場合、時刻tでニューロンiが発火したことを意味する。
# tlast[i] は各ニューロンの最後のスパイク時刻を保持。
# ==============================================================
spikes = np.zeros((nt, n_neurons))  # スパイク記録配列
tlast = np.zeros(n_neurons)  # 発火時刻記録配列

# ==============================================================
# メインシミュレーションループ
# --------------------------------------------------------------
# 各タイムステップごとに発火確率 fr*dt でスパイクを試行。
# 不応期 (tref) が経過していないニューロンではスパイクを抑制。
# ==============================================================
for i in range(nt):
    # 各ニューロンがこのステップでスパイクするかどうかを確率的に決定
    s = np.where(np.random.rand(n_neurons) < fr * dt, 1, 0)

    # 不応期を考慮したスパイク発火
    # (dt*i) > (tlast + tref) で不応期が終了しているニューロンのみ発火可能
    spikes[i] = ((dt * i) > (tlast + tref)) * s

    # 発火したニューロンの時刻を更新
    tlast = tlast * (1 - s) + dt * i * s

# ==============================================================
# 統計情報の出力
# --------------------------------------------------------------
# Num. of spikes: 全ニューロン・全時間でのスパイク総数
# Firing rate: 平均発火率 = スパイク総数 / (ニューロン数 × 時間)
# ==============================================================
print("Num. of spikes:", np.sum(spikes))
print("Firing rate:", np.sum(spikes) / (n_neurons * T))

# ==============================================================
# 可視化：スパイクラスタープロット
# --------------------------------------------------------------
# 各ニューロンのスパイク時刻を点として表示。
# 不応期の効果により、スパイク間隔が一定以上になることが観察できる。
# ==============================================================
t = np.arange(nt) * dt
plt.figure(figsize=(5, 4))
for i in range(n_neurons):
    plt.plot(t, spikes[:, i] * (i + 1), "ko", markersize=2, rasterized=True)

plt.xlabel("Time (s)")
plt.ylabel("Neuron index")
plt.xlim(0, T)
plt.ylim(0.5, n_neurons + 0.5)
plt.tight_layout()

# ==============================================================
# 結果の保存
# --------------------------------------------------------------
# 生成されたスパイク列を "PPD.pdf" として保存。
# ==============================================================
plt.savefig("PPD.pdf", dpi=300)
plt.show()
