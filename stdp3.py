# -*- coding: utf-8 -*-
"""
Created on Sun Aug 11 13:52:03 2019
@author: user
"""
# ==============================================================
# 多ニューロン間のオンラインSTDP（Spike-Timing Dependent Plasticity）
# --------------------------------------------------------------
# 本コードでは、すべてのpreニューロンが1回ずつ発火するような
# "スパイク列"を単位行列として生成し、全ての時間差 Δt における
# 重み変化 Δw(Δt) を一括で計算する。
#
# postニューロンは2つ（早い発火と遅い発火）を用意し、
# STDP曲線（Δt < 0 のLTD領域と Δt > 0 のLTP領域）を
# 同時に再現する構成となっている。
# ==============================================================

import numpy as np
import matplotlib.pyplot as plt

# 乱数シードの固定（再現性確保）
np.random.seed(seed=0)

# ==============================================================
# シミュレーションパラメータ設定
# --------------------------------------------------------------
# dt : 時間刻み幅 [s]
# T  : シミュレーション全体時間 [s]
# nt : 総ステップ数
# N_pre : preニューロン数（= ntと同じ、各時刻で1つずつ発火）
# N_post: postニューロン数（2種類のタイミングで発火）
# tau_p, tau_m : トレース時定数 [s]
# A_p, A_m : LTP/LTD の学習係数
# ==============================================================
dt = 1e-3  # sec (= 1 ms)
T = 5e-2  # sec (= 50 ms)
nt = round(T / dt)

N_pre = nt  # preニューロン（各時刻1個ずつ発火）
N_post = 2  # postニューロン（早い発火と遅い発火）

tau_p = tau_m = 2e-2  # トレースの時定数（20 ms）
A_p = 0.01  # LTPの係数
A_m = 1.05 * A_p  # LTDの係数（恒常性維持のためLTPよりやや大）

# ==============================================================
# スパイク列の定義
# --------------------------------------------------------------
# spike_pre : (N_pre, nt)
# 各時刻tごとに1つのpreニューロンが発火する単位行列
#
# spike_post : (N_post, nt)
# 1つ目のpostニューロンは最後に発火
# 2つ目のpostニューロンは最初に発火
# これにより Δt > 0 / Δt < 0 の両方を同時に評価できる
# ==============================================================
spike_pre = np.eye(N_pre)
spike_post = np.zeros((N_post, nt))
spike_post[0, -1] = 1  # postニューロン1: 遅れて発火 (Δt > 0)
spike_post[1, 0] = 1  # postニューロン2: 先に発火 (Δt < 0)

# ==============================================================
# 状態変数の初期化
# --------------------------------------------------------------
# x_pre  : preニューロンのトレース変数
# x_post : postニューロンのトレース変数
# W      : シナプス重み行列 (N_post x N_pre)
# ==============================================================
x_pre = np.zeros(N_pre)
x_post = np.zeros(N_post)
W = np.zeros((N_post, N_pre))

# ==============================================================
# オンラインSTDPの逐次計算ループ
# --------------------------------------------------------------
# 各時刻 t で次の処理を実行：
#   1. pre/postスパイクを1次元ベクトル化
#   2. STDP学習則に基づく重み更新 dW の計算
#   3. トレース変数 x_pre, x_post の指数減衰更新
# ==============================================================
for t in range(nt):
    # 1次元配列を縦・横ベクトルに変換
    spike_pre_ = np.expand_dims(spike_pre[:, t], 0)  # (1, N_pre)
    spike_post_ = np.expand_dims(spike_post[:, t], 1)  # (N_post, 1)
    x_pre_ = np.expand_dims(x_pre, 0)  # (1, N_pre)
    x_post_ = np.expand_dims(x_post, 1)  # (N_post, 1)

    # ----------------------------------------------------------
    # STDP重み更新ルール
    # LTP: A_p * (postスパイク × preトレース)
    # LTD: A_m * (postトレース × preスパイク)
    # ----------------------------------------------------------
    dW = A_p * np.matmul(spike_post_, x_pre_)  # LTP成分
    dW -= A_m * np.matmul(x_post_, spike_pre_)  # LTD成分
    W += dW  # 重み更新

    # トレース更新（指数減衰＋スパイク加算）
    x_pre = x_pre * (1 - dt / tau_p) + spike_pre[:, t]
    x_post = x_post * (1 - dt / tau_m) + spike_post[:, t]

# ==============================================================
# Δt（スパイク時間差）ごとの重み変化を再構成
# --------------------------------------------------------------
# postニューロン1（遅発火）→ LTP領域（Δt > 0）
# postニューロン2（早発火）→ LTD領域（Δt < 0）
# ==============================================================
delta_w = np.zeros(nt * 2 - 1)
delta_w[:nt] = W[0, :]  # post遅れ → Δt > 0
delta_w[nt:] = W[1, 1:]  # post先行 → Δt < 0

# ==============================================================
# 可視化
# --------------------------------------------------------------
# x軸：スパイク時間差 Δt [ms]
# y軸：シナプス重み変化 Δw
# 教科書的なSTDPカーブ（非対称な指数関数形状）が得られる
# ==============================================================
time = np.arange(-T, T - dt, dt) * 1e3  # [ms]
plt.figure(figsize=(5, 4))
plt.plot(time, delta_w[::-1], color="k")
plt.hlines(0, -50, 50)
plt.xlabel("$\Delta t$ (ms)")  # スパイク時間差
plt.ylabel("$\Delta w$")  # 重み変化
plt.xlim(-50, 50)
plt.tight_layout()
plt.savefig("online_stdp2.pdf")

# ==============================================================
# 💬 コメント
# --------------------------------------------------------------
# このシミュレーションは、全てのΔtに対してSTDP学習則を評価するための
# ベクトル化された実装である。
# 2つのpostニューロンを利用することで、Δtが正・負の両領域を同時に算出。
# 得られるΔw(Δt)カーブは非対称な形状となり、
# pre→postでLTP、post→preでLTDを示すことが確認できる。
# ==============================================================
