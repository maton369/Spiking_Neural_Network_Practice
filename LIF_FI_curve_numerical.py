# -*- coding: utf-8 -*-
# ==============================================================
# LIFニューロンのF-Iカーブ（入力電流と発火率の関係）を数値的に算出
# --------------------------------------------------------------
# 本スクリプトは、単一のLeaky Integrate-and-Fireニューロンを対象に、
# 入力電流の強さと発火頻度（Hz）の関係（F-I特性）をシミュレートする。
# ==============================================================

import numpy as np
import matplotlib.pyplot as plt
from tqdm import tqdm

# ==============================================================
# パラメータ設定
# --------------------------------------------------------------
# dt   : 時間刻み幅 [s]
# T    : シミュレーション全体の時間 [s]
# nt   : 総ステップ数
# tref : 不応期（スパイク後の休止時間）[s]
# tc_m : 膜時定数 [s]
# vrest: 静止膜電位 [mV]
# vreset: リセット電位 [mV]
# vthr : 発火閾値 [mV]
# ==============================================================
dt = 5e-5  # 時間ステップ [s]
T = 1  # シミュレーション時間 [s]
nt = round(T / dt)  # ステップ数

tref = 5e-3  # 不応期 [s]
tc_m = 1e-2  # 膜時定数 [s]
vrest = 0  # 静止膜電位 [mV]
vreset = 0  # リセット電位 [mV]
vthr = 1  # 閾値電位 [mV]

I_max = 3  # 最大入力電流 [nA]
N = 100  # 入力電流のサンプル数

# ==============================================================
# 入力電流の設定
# --------------------------------------------------------------
# np.linspaceを用いて0〜I_maxの範囲をN分割。
# 各入力電流値に対してLIFモデルを独立にシミュレート。
# ==============================================================
I = np.linspace(0, I_max, N)  # 入力電流 [nA]
spikes = np.zeros((N, nt))  # 各電流に対するスパイク時系列を格納

# ==============================================================
# シミュレーション開始
# --------------------------------------------------------------
# 各入力電流 I[i] に対して、膜電位の時間発展を追跡。
# 発火時刻をカウントし、スパイク発生頻度を計算する。
# ==============================================================
for i in tqdm(range(N)):  # tqdmで進行状況を可視化
    # --- 初期化 ---
    v = vreset  # 初期膜電位
    tlast = 0  # 最後のスパイク発火時刻を保持

    # --- 時間発展 ---
    for t in range(nt):
        # 膜電位の微分方程式：
        # dv/dt = (vrest - v + I[i]) / tc_m
        dv = (vrest - v + I[i]) / tc_m

        # 不応期を考慮：t > (tlast + tref) のときのみ更新
        update = 1 if ((dt * t) > (tlast + tref)) else 0
        v = v + update * dv * dt

        # --- 発火判定 ---
        s = 1 if (v >= vthr) else 0  # 閾値超過でスパイク発火
        # 発火時刻を更新（s=1の場合のみ現在時刻を記録）
        tlast = tlast * (1 - s) + dt * t * s

        # --- 発火履歴を保存 ---
        spikes[i, t] = s

        # --- 膜電位のリセット ---
        v = v * (1 - s) + vreset * s

# ==============================================================
# 発火率（Firing Rate）の計算と可視化
# --------------------------------------------------------------
# 各入力電流に対するスパイク数を数え、1秒あたりの発火率(Hz)を算出。
# F-Iカーブとして描画。
# ==============================================================
rate = np.sum(spikes, axis=1) / T  # 発火率 [Hz] = 発火回数 / 時間

plt.figure(figsize=(4, 3))
plt.plot(I, rate, color="k")
plt.xlabel("Input current (nA)")
plt.ylabel("Firing rate (Hz)")
plt.xlim(0, I_max)
plt.tight_layout()
plt.savefig("LIF_FI_numerical.pdf")  # F-Iカーブを保存
# plt.show()  # 表示する場合はコメントアウト解除
